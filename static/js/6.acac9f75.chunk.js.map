{"version":3,"sources":["../../src/bai.ts","../../../node_modules/@babel/runtime-corejs3/core-js-stable/array/is-array.js","../../../node_modules/@babel/runtime-corejs3/core-js-stable/symbol.js","../../../node_modules/@babel/runtime-corejs3/core-js-stable/array/from.js","../../../node_modules/core-js-pure/es/object/get-own-property-descriptor.js","../../../node_modules/core-js-pure/es/object/get-own-property-symbols.js","../../src/virtualOffset.ts","../../src/chunk.ts","../../src/indexFile.ts","../../src/csi.ts","../../../node_modules/@babel/runtime-corejs3/helpers/interopRequireWildcard.js","../../src/bamFile.ts","../../../node_modules/@babel/runtime-corejs3/helpers/wrapAsyncGenerator.js","../../../node_modules/@babel/runtime-corejs3/core-js/symbol/async-iterator.js","../../../node_modules/@babel/runtime-corejs3/helpers/AwaitValue.js","../../../node_modules/@babel/runtime-corejs3/helpers/awaitAsyncGenerator.js","../../../node_modules/@babel/runtime-corejs3/helpers/asyncGeneratorDelegate.js","../../../node_modules/@babel/runtime-corejs3/helpers/asyncIterator.js","../../src/record.ts","../../src/sam.ts","../../../node_modules/@babel/runtime-corejs3/core-js-stable/object/define-property.js","../../../node_modules/core-js-pure/stable/object/define-property.js","../../../node_modules/core-js-pure/stable/array/is-array.js","../../../node_modules/core-js-pure/features/get-iterator-method.js","../../../node_modules/core-js-pure/stable/symbol/index.js","../../../node_modules/core-js-pure/stable/array/from.js","../../../node_modules/core-js-pure/stable/object/define-properties.js","../../../node_modules/core-js-pure/es/object/define-properties.js","../../../node_modules/core-js-pure/modules/es.object.define-properties.js","../../../node_modules/core-js-pure/stable/object/get-own-property-descriptors.js","../../../node_modules/core-js-pure/es/object/get-own-property-descriptors.js","../../../node_modules/core-js-pure/modules/es.object.get-own-property-descriptors.js","../../../node_modules/core-js-pure/internals/own-keys.js","../../../node_modules/core-js-pure/stable/object/get-own-property-descriptor.js","../../../node_modules/core-js-pure/modules/es.object.get-own-property-descriptor.js","../../../node_modules/core-js-pure/stable/object/get-own-property-symbols.js","../../../node_modules/core-js-pure/stable/reflect/construct.js","../../../node_modules/@babel/runtime-corejs3/core-js-stable/set-timeout.js","../../../node_modules/core-js-pure/stable/set-timeout.js","../../../node_modules/core-js-pure/modules/web.timers.js","../../../node_modules/@babel/runtime-corejs3/core-js/object/get-own-property-descriptor.js","../../../node_modules/core-js-pure/features/object/get-own-property-descriptor.js","../../../node_modules/@babel/runtime-corejs3/core-js/weak-map.js","../../../node_modules/core-js-pure/features/weak-map/index.js","../../../node_modules/core-js-pure/es/weak-map/index.js","../../../node_modules/core-js-pure/modules/es.weak-map.js","../../../node_modules/core-js-pure/internals/collection-weak.js","../../../node_modules/core-js-pure/modules/esnext.weak-map.emplace.js","../../../node_modules/core-js-pure/modules/esnext.weak-map.from.js","../../../node_modules/core-js-pure/modules/esnext.weak-map.of.js","../../../node_modules/core-js-pure/modules/esnext.weak-map.delete-all.js","../../../node_modules/core-js-pure/modules/esnext.weak-map.upsert.js","../../../node_modules/@babel/runtime-corejs3/core-js-stable/date/now.js","../../../node_modules/core-js-pure/stable/date/now.js","../../../node_modules/core-js-pure/es/date/now.js","../../../node_modules/core-js-pure/modules/es.date.now.js","../../../node_modules/@babel/runtime-corejs3/helpers/AsyncGenerator.js","../../../node_modules/core-js-pure/features/symbol/async-iterator.js","../../../node_modules/core-js-pure/es/symbol/async-iterator.js","../../src/constants.ts","../../src/htsget.ts","../../../node_modules/@babel/runtime-corejs3/helpers/objectWithoutProperties.js","../../../node_modules/@babel/runtime-corejs3/core-js/object/get-own-property-symbols.js","../../../node_modules/core-js-pure/features/object/get-own-property-symbols.js","../../../node_modules/@babel/runtime-corejs3/helpers/objectWithoutPropertiesLoose.js","../../../node_modules/@babel/runtime-corejs3/core-js/object/keys.js","../../../node_modules/core-js-pure/features/object/keys.js","../../../node_modules/@babel/runtime-corejs3/core-js-stable/instance/starts-with.js","../../../node_modules/core-js-pure/stable/instance/starts-with.js","../../../node_modules/core-js-pure/es/instance/starts-with.js","../../../node_modules/core-js-pure/es/string/virtual/starts-with.js","../../../node_modules/core-js-pure/modules/es.string.starts-with.js","../../../node_modules/cross-fetch/dist/browser-polyfill.js","../../../node_modules/@babel/runtime-corejs3/helpers/defineProperty.js","../../src/index.ts","../../../node_modules/@babel/runtime-corejs3/core-js/get-iterator-method.js","../../../node_modules/@babel/runtime-corejs3/core-js-stable/object/define-properties.js","../../../node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors.js","../../../node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor.js","../../../node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols.js","../../../node_modules/@babel/runtime-corejs3/core-js-stable/reflect/construct.js","../../src/util.ts"],"names":["BAI_MAGIC","roundDown","n","roundUp","BAI","bytes","offset","lineCount","longToNumber","Long","Array","refId","opts","this","parse","prom","index","ret","data","bai","maxBlockSize","filehandle","readFile","Error","binLimit","currOffset","i","refCount","abortBreakPoint","binCount","stats","binIndex","j","bin","parsePseudoBin","chunkCount","chunks","k","u","fromBytes","v","Chunk","linearCount","linearIndex","seqId","start","end","range","undefined","indexData","seqIdx","length","e","s","depths","totalSize","blockPosition","currentPos","score","d","beg","min","max","ba","overlappingBins","reg2bins","binChunks","c","nintv","lowest","minLin","Math","maxLin","vp","optimizeChunks","IndexFile","module","exports","require","Object","getOwnPropertyDescriptor","it","key","sham","path","getOwnPropertySymbols","bigendian","VirtualOffset","b","dataPosition","args","fetchedSize","minv","compareTo","maxv","_fetchedSize","renameRefSeq","virtualOffset","currentFdl","AbortablePromiseCache","cache","QuickLRU","maxSize","fill","signal","_parseCache","get","indices","rshift","num","CSI","auxLength","0","1","2","ref","String","nameSectionLength","_parseNameBytes","namesBytes","currRefId","currNameStart","refIdToName","refNameToId","refName","csi","buffer","unzip","depth","parseAuxData","loffset","l","t","minShift","bins","_Object$getOwnPropertyDescriptor","_Object$defineProperty","_typeof","_WeakMap","_getRequireWildcardCache","obj","__esModule","has","newObj","hasPropertyDescriptor","prototype","hasOwnProperty","call","desc","set","BAM_MAGIC","blockLen","BamFile","bamFilehandle","bamPath","bamUrl","baiPath","baiFilehandle","baiUrl","csiPath","csiFilehandle","csiUrl","cacheSize","fetchSizeLimit","chunkSizeLimit","yieldThreadTime","renameRefSeqs","LocalFile","RemoteFile","LRU","origOpts","makeOpts","bam","read","Buffer","res","bytesRead","uncba","headLen","_readRefSeqs","chrToIndex","indexToChr","parseHeaderText","getHeader","header","refSeqBytes","nRef","p","lName","lRef","console","chr","viewAsPairs","pairAcrossChr","maxInsertSize","records","streamRecordsForRange","chunk","chrId","size","a","featPromises","done","cpositions","dpositions","promise","recs","feature","checkAbortSignal","unmatedPairs","readIds","readNames","name","id","matePromises","mateBlocks","mateChunks","pos","item","ary","mateTotalSize","mateFeatPromises","feats","mateRecs","newMateFeats","featuresRet","newMates","result","abortSignal","bufsize","unzipChunkSlice","blockStart","sink","last","blockSize","blockEnd","BAMFeature","byteArray","fileOffset","crc32","timeout","seqName","hasRefSeq","indexCov","AsyncGenerator","fn","apply","arguments","value","wrapped","AwaitValue","_Symbol$iterator","_Symbol","_Promise","inner","awaitWrap","iter","waiting","pump","resolve","next","_getIteratorMethod","_Symbol$asyncIterator","iterable","method","TypeError","SEQRET_DECODER","CIGAR_DECODER","split","BamRecord","field","_get","_parseTag","tags","_tagList","seen","lt","mq","lseq","qseq","isReverseComplemented","isMateReverseComplemented","nl","toString","tagName","_tagOffset","lcTag","tag","type","cc","Btype","limit","cigop","cigar","op","Constants","numCigarOps","seqLen","lref","lop","seqBytes","len","buf","sb","_refID","s1","s2","o1","o2","tmp","readInt32LE","text","lines","line","fields","parsedFields","f","parent","getIteratorMethod","defineProperties","T","D","$","DESCRIPTORS","target","stat","forced","getOwnPropertyDescriptors","ownKeys","toIndexedObject","getOwnPropertyDescriptorModule","createProperty","object","descriptor","O","keys","getBuiltIn","getOwnPropertyNamesModule","getOwnPropertySymbolsModule","anObject","concat","fails","nativeGetOwnPropertyDescriptor","FAILS_ON_PRIMITIVES","setTimeout","global","userAgent","slice","wrap","scheduler","handler","boundArgs","Function","bind","test","setInterval","WeakMap","InternalWeakMap","redefineAll","InternalMetadataModule","collection","collectionWeak","isObject","enforceIternalState","enforce","NATIVE_WEAK_MAP","IS_IE11","ActiveXObject","isExtensible","wrapper","init","$WeakMap","getConstructor","REQUIRED","WeakMapPrototype","nativeDelete","nativeHas","nativeGet","nativeSet","state","frozen","getWeakData","anInstance","iterate","ArrayIterationModule","$has","InternalStateModule","setInternalState","internalStateGetterFor","getterFor","find","findIndex","uncaughtFrozenStore","store","UncaughtFrozenStore","entries","findUncaughtFrozen","entry","push","splice","CONSTRUCTOR_NAME","IS_MAP","ADDER","C","that","AS_ENTRIES","getInternalState","define","add","proto","real","emplace","from","of","IS_PURE","collectionDeleteAll","deleteAll","upsert","Date","now","getTime","gen","front","back","resume","arg","wrappedAwait","then","settle","err","reject","_invoke","request","WrappedWellKnownSymbolModule","BAM_FPAIRED","BAM_FPROPER_PAIR","BAM_FUNMAP","BAM_FMUNMAP","BAM_FREVERSE","BAM_FMREVERSE","BAM_FREAD1","BAM_FREAD2","BAM_FSECONDARY","BAM_FQCFAIL","BAM_FDUP","BAM_FSUPPLEMENTARY","arr","url","headers","rest","fetch","elt","HtsgetFile","base","params","c2","baseUrl","trackId","ok","headerText","samHeader","idToName","nameToId","sqLines","sqLine","_indexOfInstanceProperty","_Object$getOwnPropertySymbols","objectWithoutPropertiesLoose","source","excluded","sourceSymbolKeys","propertyIsEnumerable","_Object$keys","sourceKeys","startsWith","StringPrototype","own","entryVirtual","toLength","notARegExp","requireObjectCoercible","correctIsRegExpLogic","$startsWith","CORRECT_IS_REGEXP_LOGIC","writable","searchString","search","self","support","Symbol","Blob","viewClasses","isArrayBufferView","ArrayBuffer","isView","indexOf","normalizeName","toLowerCase","normalizeValue","iteratorFor","items","iterator","shift","Headers","map","forEach","append","isArray","getOwnPropertyNames","consumed","body","bodyUsed","Promise","fileReaderReady","reader","onload","onerror","error","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","bufferClone","view","Uint8Array","byteLength","Body","_initBody","_bodyInit","_bodyText","isPrototypeOf","_bodyBlob","FormData","_bodyFormData","URLSearchParams","DataView","_bodyArrayBuffer","rejected","arrayBuffer","readAsText","readBlobAsText","chars","fromCharCode","join","readArrayBufferAsText","formData","decode","json","JSON","oldValue","callback","thisArg","values","methods","Request","input","options","credentials","mode","upcased","toUpperCase","normalizeMethod","referrer","form","trim","replace","decodeURIComponent","parseHeaders","rawHeaders","parts","Response","bodyInit","status","statusText","clone","response","redirectStatuses","redirect","RangeError","location","DOMException","message","stack","create","constructor","aborted","xhr","XMLHttpRequest","abortXhr","abort","getAllResponseHeaders","responseURL","responseText","ontimeout","onabort","open","withCredentials","responseType","setRequestHeader","addEventListener","onreadystatechange","readyState","removeEventListener","send","polyfill","enumerable","configurable","ms","long","mergedChunks","lastChunk","dif","c0","c1","canMergeBlocks","chunk1","chunk2"],"mappings":"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","file":"static/js/6.acac9f75.chunk.js","sourcesContent":["import Long from 'long'\nimport { fromBytes } from './virtualOffset'\nimport Chunk from './chunk'\n\nimport IndexFile from './indexFile'\nimport { longToNumber, abortBreakPoint, optimizeChunks, BaseOpts } from './util'\n\nconst BAI_MAGIC = 21578050 // BAI\\1\n\nfunction roundDown(n: number, multiple: number) {\n  return n - (n % multiple)\n}\nfunction roundUp(n: number, multiple: number) {\n  return n - (n % multiple) + multiple\n}\n\nexport default class BAI extends IndexFile {\n  parsePseudoBin(bytes: Buffer, offset: number) {\n    const lineCount = longToNumber(\n      Long.fromBytesLE(Array.prototype.slice.call(bytes, offset + 16, offset + 24), true),\n    )\n    return { lineCount }\n  }\n\n  async lineCount(refId: number, opts: BaseOpts = {}) {\n    const prom = await this.parse(opts)\n    const index = prom.indices[refId]\n    if (!index) {\n      return -1\n    }\n    const ret = index.stats || {}\n    return ret.lineCount === undefined ? -1 : ret.lineCount\n  }\n\n  // fetch and parse the index\n  async _parse(opts: BaseOpts = {}) {\n    const data: { [key: string]: any } = { bai: true, maxBlockSize: 1 << 16 }\n    const bytes = (await this.filehandle.readFile(opts)) as Buffer\n\n    // check BAI magic numbers\n    if (bytes.readUInt32LE(0) !== BAI_MAGIC) {\n      throw new Error('Not a BAI file')\n    }\n\n    data.refCount = bytes.readInt32LE(4)\n    const depth = 5\n    const binLimit = ((1 << ((depth + 1) * 3)) - 1) / 7\n\n    // read the indexes for each reference sequence\n    data.indices = new Array(data.refCount)\n    let currOffset = 8\n    for (let i = 0; i < data.refCount; i += 1) {\n      await abortBreakPoint(opts.signal)\n\n      // the binning index\n      const binCount = bytes.readInt32LE(currOffset)\n      let stats\n\n      currOffset += 4\n      const binIndex: { [key: number]: Chunk[] } = {}\n      for (let j = 0; j < binCount; j += 1) {\n        const bin = bytes.readUInt32LE(currOffset)\n        currOffset += 4\n        if (bin === binLimit + 1) {\n          currOffset += 4\n          stats = this.parsePseudoBin(bytes, currOffset)\n          currOffset += 32\n        } else if (bin > binLimit + 1) {\n          throw new Error('bai index contains too many bins, please use CSI')\n        } else {\n          const chunkCount = bytes.readInt32LE(currOffset)\n          currOffset += 4\n          const chunks = new Array(chunkCount)\n          for (let k = 0; k < chunkCount; k += 1) {\n            const u = fromBytes(bytes, currOffset)\n            const v = fromBytes(bytes, currOffset + 8)\n            currOffset += 16\n            this._findFirstData(data, u)\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          binIndex[bin] = chunks\n        }\n      }\n\n      const linearCount = bytes.readInt32LE(currOffset)\n      currOffset += 4\n      // as we're going through the linear index, figure out\n      // the smallest virtual offset in the indexes, which\n      // tells us where the BAM header ends\n      const linearIndex = new Array(linearCount)\n      for (let k = 0; k < linearCount; k += 1) {\n        linearIndex[k] = fromBytes(bytes, currOffset)\n        currOffset += 8\n        this._findFirstData(data, linearIndex[k])\n      }\n\n      data.indices[i] = { binIndex, linearIndex, stats }\n    }\n\n    return data\n  }\n\n  async indexCov(\n    seqId: number,\n    start?: number,\n    end?: number,\n    opts: BaseOpts = {},\n  ): Promise<{ start: number; end: number; score: number }[]> {\n    const v = 16384\n    const range = start !== undefined\n    const indexData = await this.parse(opts)\n    const seqIdx = indexData.indices[seqId]\n    if (!seqIdx) {\n      return []\n    }\n    const { linearIndex = [], stats } = seqIdx\n    if (!linearIndex.length) {\n      return []\n    }\n    const e = end !== undefined ? roundUp(end, v) : (linearIndex.length - 1) * v\n    const s = start !== undefined ? roundDown(start, v) : 0\n    let depths\n    if (range) {\n      depths = new Array((e - s) / v)\n    } else {\n      depths = new Array(linearIndex.length - 1)\n    }\n    const totalSize = linearIndex[linearIndex.length - 1].blockPosition\n    if (e > (linearIndex.length - 1) * v) {\n      throw new Error('query outside of range of linear index')\n    }\n    let currentPos = linearIndex[s / v].blockPosition\n    for (let i = s / v, j = 0; i < e / v; i++, j++) {\n      depths[j] = {\n        score: linearIndex[i + 1].blockPosition - currentPos,\n        start: i * v,\n        end: i * v + v,\n      }\n      currentPos = linearIndex[i + 1].blockPosition\n    }\n    return depths.map(d => {\n      return { ...d, score: (d.score * stats.lineCount) / totalSize }\n    })\n  }\n\n  /**\n   * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)\n   * @returns {Array[number]}\n   */\n  reg2bins(beg: number, end: number) {\n    end -= 1\n    return [\n      [0, 0],\n      [1 + (beg >> 26), 1 + (end >> 26)],\n      [9 + (beg >> 23), 9 + (end >> 23)],\n      [73 + (beg >> 20), 73 + (end >> 20)],\n      [585 + (beg >> 17), 585 + (end >> 17)],\n      [4681 + (beg >> 14), 4681 + (end >> 14)],\n    ]\n  }\n\n  async blocksForRange(refId: number, min: number, max: number, opts: BaseOpts = {}) {\n    if (min < 0) {\n      min = 0\n    }\n\n    const indexData = await this.parse(opts)\n    if (!indexData) {\n      return []\n    }\n    const ba = indexData.indices[refId]\n    if (!ba) {\n      return []\n    }\n\n    const overlappingBins = this.reg2bins(min, max) // List of bin #s that overlap min, max\n    const chunks: Chunk[] = []\n\n    // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n    for (const [start, end] of overlappingBins) {\n      for (let bin = start; bin <= end; bin++) {\n        if (ba.binIndex[bin]) {\n          const binChunks = ba.binIndex[bin]\n          for (let c = 0; c < binChunks.length; ++c) {\n            chunks.push(new Chunk(binChunks[c].minv, binChunks[c].maxv, bin))\n          }\n        }\n      }\n    }\n\n    // Use the linear index to find minimum file position of chunks that could contain alignments in the region\n    const nintv = ba.linearIndex.length\n    let lowest = null\n    const minLin = Math.min(min >> 14, nintv - 1)\n    const maxLin = Math.min(max >> 14, nintv - 1)\n    for (let i = minLin; i <= maxLin; ++i) {\n      const vp = ba.linearIndex[i]\n      if (vp) {\n        if (!lowest || vp.compareTo(lowest) < 0) {\n          lowest = vp\n        }\n      }\n    }\n\n    return optimizeChunks(chunks, lowest)\n  }\n}\n","module.exports = require(\"core-js-pure/stable/array/is-array\");","module.exports = require(\"core-js-pure/stable/symbol\");","module.exports = require(\"core-js-pure/stable/array/from\");","require('../../modules/es.object.get-own-property-descriptor');\nvar path = require('../../internals/path');\n\nvar Object = path.Object;\n\nvar getOwnPropertyDescriptor = module.exports = function getOwnPropertyDescriptor(it, key) {\n  return Object.getOwnPropertyDescriptor(it, key);\n};\n\nif (Object.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor.sham = true;\n","require('../../modules/es.symbol');\nvar path = require('../../internals/path');\n\nmodule.exports = path.Object.getOwnPropertySymbols;\n","export default class VirtualOffset {\n  public blockPosition: number\n  public dataPosition: number\n  constructor(blockPosition: number, dataPosition: number) {\n    this.blockPosition = blockPosition // < offset of the compressed data block\n    this.dataPosition = dataPosition // < offset into the uncompressed data\n  }\n\n  toString() {\n    return `${this.blockPosition}:${this.dataPosition}`\n  }\n\n  compareTo(b: VirtualOffset) {\n    return this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition\n  }\n\n  static min(...args: VirtualOffset[]) {\n    let min\n    let i = 0\n    for (; !min; i += 1) {\n      min = args[i]\n    }\n    for (; i < args.length; i += 1) {\n      if (min.compareTo(args[i]) > 0) {\n        min = args[i]\n      }\n    }\n    return min\n  }\n}\nexport function fromBytes(bytes: Buffer, offset = 0, bigendian = false) {\n  if (bigendian) {\n    throw new Error('big-endian virtual file offsets not implemented')\n  }\n\n  return new VirtualOffset(\n    bytes[offset + 7] * 0x10000000000 +\n      bytes[offset + 6] * 0x100000000 +\n      bytes[offset + 5] * 0x1000000 +\n      bytes[offset + 4] * 0x10000 +\n      bytes[offset + 3] * 0x100 +\n      bytes[offset + 2],\n    (bytes[offset + 1] << 8) | bytes[offset],\n  )\n}\n","import VirtualOffset from './virtualOffset'\n\n// little class representing a chunk in the index\nexport default class Chunk {\n  public minv: VirtualOffset\n  public maxv: VirtualOffset\n  public bin: number\n  public _fetchedSize?: number\n\n  /**\n   * @param {VirtualOffset} minv\n   * @param {VirtualOffset} maxv\n   * @param {number} bin\n   * @param {number} [fetchedSize]\n   */\n  constructor(minv: VirtualOffset, maxv: VirtualOffset, bin: number, fetchedSize = undefined) {\n    this.minv = minv\n    this.maxv = maxv\n    this.bin = bin\n    this._fetchedSize = fetchedSize\n  }\n\n  toUniqueString() {\n    return `${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`\n  }\n\n  toString() {\n    return this.toUniqueString()\n  }\n\n  compareTo(b: Chunk) {\n    return this.minv.compareTo(b.minv) || this.maxv.compareTo(b.maxv) || this.bin - b.bin\n  }\n\n  fetchedSize() {\n    if (this._fetchedSize !== undefined) {\n      return this._fetchedSize\n    }\n    return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition\n  }\n}\n","import AbortablePromiseCache from 'abortable-promise-cache'\nimport QuickLRU from 'quick-lru'\nimport { GenericFilehandle } from 'generic-filehandle'\nimport VirtualOffset from './virtualOffset'\nimport Chunk from './chunk'\nimport { BaseOpts } from './util'\n\nexport default abstract class IndexFile {\n  public filehandle: GenericFilehandle\n  public renameRefSeq: Function\n  private _parseCache: any\n\n  /**\n   * @param {filehandle} filehandle\n   * @param {function} [renameRefSeqs]\n   */\n  constructor({\n    filehandle,\n    renameRefSeq = (n: string) => n,\n  }: {\n    filehandle: GenericFilehandle\n    renameRefSeq?: (a: string) => string\n  }) {\n    this.filehandle = filehandle\n    this.renameRefSeq = renameRefSeq\n  }\n  public abstract async lineCount(refId: number): Promise<number>\n  protected abstract async _parse(opts?: BaseOpts): Promise<any>\n  public abstract async indexCov(\n    refId: number,\n    start?: number,\n    end?: number,\n  ): Promise<{ start: number; end: number; score: number }[]>\n  public abstract async blocksForRange(\n    chrId: number,\n    start: number,\n    end: number,\n    opts: BaseOpts,\n  ): Promise<Chunk[]>\n\n  _findFirstData(data: any, virtualOffset: VirtualOffset) {\n    const currentFdl = data.firstDataLine\n    if (currentFdl) {\n      data.firstDataLine = currentFdl.compareTo(virtualOffset) > 0 ? virtualOffset : currentFdl\n    } else {\n      data.firstDataLine = virtualOffset\n    }\n  }\n\n  async parse(opts: BaseOpts = {}) {\n    if (!this._parseCache) {\n      this._parseCache = new AbortablePromiseCache({\n        cache: new QuickLRU({ maxSize: 1 }),\n        fill: (opts: BaseOpts, signal?: AbortSignal) => {\n          return this._parse({ ...opts, signal })\n        },\n      })\n    }\n    return this._parseCache.get('index', opts, opts.signal)\n  }\n\n  async hasRefSeq(seqId: number, opts: BaseOpts = {}) {\n    return !!((await this.parse(opts)).indices[seqId] || {}).binIndex\n  }\n}\n","import Long from 'long'\nimport { unzip } from '@gmod/bgzf-filehandle'\nimport VirtualOffset, { fromBytes } from './virtualOffset'\nimport Chunk from './chunk'\nimport { longToNumber, abortBreakPoint, optimizeChunks, BaseOpts } from './util'\n\nimport IndexFile from './indexFile'\n\nconst CSI1_MAGIC = 21582659 // CSI\\1\nconst CSI2_MAGIC = 38359875 // CSI\\2\n\nfunction lshift(num: number, bits: number) {\n  return num * 2 ** bits\n}\nfunction rshift(num: number, bits: number) {\n  return Math.floor(num / 2 ** bits)\n}\n\nexport default class CSI extends IndexFile {\n  private maxBinNumber: number\n  private depth: number\n  private minShift: number\n  constructor(args: any) {\n    super(args)\n    this.maxBinNumber = 0\n    this.depth = 0\n    this.minShift = 0\n  }\n  async lineCount(refId: number): Promise<number> {\n    const indexData = await this.parse()\n    if (!indexData) {\n      return -1\n    }\n    const idx = indexData.indices[refId]\n    if (!idx) {\n      return -1\n    }\n    const { stats } = indexData.indices[refId]\n    if (stats) {\n      return stats.lineCount\n    }\n    return -1\n  }\n\n  async indexCov() {\n    return []\n  }\n\n  parseAuxData(bytes: Buffer, offset: number, auxLength: number) {\n    if (auxLength < 30) {\n      return {}\n    }\n\n    const data: { [key: string]: any } = {}\n    data.formatFlags = bytes.readInt32LE(offset)\n    data.coordinateType = data.formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed'\n    data.format = ({ 0: 'generic', 1: 'SAM', 2: 'VCF' } as { [key: number]: string })[\n      data.formatFlags & 0xf\n    ]\n    if (!data.format) {\n      throw new Error(`invalid Tabix preset format flags ${data.formatFlags}`)\n    }\n    data.columnNumbers = {\n      ref: bytes.readInt32LE(offset + 4),\n      start: bytes.readInt32LE(offset + 8),\n      end: bytes.readInt32LE(offset + 12),\n    }\n    data.metaValue = bytes.readInt32LE(offset + 16)\n    data.metaChar = data.metaValue ? String.fromCharCode(data.metaValue) : ''\n    data.skipLines = bytes.readInt32LE(offset + 20)\n    const nameSectionLength = bytes.readInt32LE(offset + 24)\n\n    Object.assign(\n      data,\n      this._parseNameBytes(bytes.slice(offset + 28, offset + 28 + nameSectionLength)),\n    )\n    return data\n  }\n\n  _parseNameBytes(namesBytes: Buffer) {\n    let currRefId = 0\n    let currNameStart = 0\n    const refIdToName = []\n    const refNameToId: { [key: string]: number } = {}\n    for (let i = 0; i < namesBytes.length; i += 1) {\n      if (!namesBytes[i]) {\n        if (currNameStart < i) {\n          let refName = namesBytes.toString('utf8', currNameStart, i)\n          refName = this.renameRefSeq(refName)\n          refIdToName[currRefId] = refName\n          refNameToId[refName] = currRefId\n        }\n        currNameStart = i + 1\n        currRefId += 1\n      }\n    }\n    return { refNameToId, refIdToName }\n  }\n\n  // fetch and parse the index\n  async _parse(opts: { signal?: AbortSignal }) {\n    const data: { [key: string]: any } = { csi: true, maxBlockSize: 1 << 16 }\n    const buffer = (await this.filehandle.readFile(opts)) as Buffer\n    const bytes = await unzip(buffer)\n\n    // check TBI magic numbers\n    if (bytes.readUInt32LE(0) === CSI1_MAGIC) {\n      data.csiVersion = 1\n    } else if (bytes.readUInt32LE(0) === CSI2_MAGIC) {\n      data.csiVersion = 2\n    } else {\n      throw new Error('Not a CSI file')\n      // TODO: do we need to support big-endian CSI files?\n    }\n\n    this.minShift = bytes.readInt32LE(4)\n    this.depth = bytes.readInt32LE(8)\n    this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7\n    const auxLength = bytes.readInt32LE(12)\n    if (auxLength) {\n      Object.assign(data, this.parseAuxData(bytes, 16, auxLength))\n    }\n    data.refCount = bytes.readInt32LE(16 + auxLength)\n\n    // read the indexes for each reference sequence\n    data.indices = new Array(data.refCount)\n    let currOffset = 16 + auxLength + 4\n    for (let i = 0; i < data.refCount; i += 1) {\n      await abortBreakPoint(opts.signal)\n      // the binning index\n      const binCount = bytes.readInt32LE(currOffset)\n      currOffset += 4\n      const binIndex: { [key: string]: Chunk[] } = {}\n      let stats // < provided by parsing a pseudo-bin, if present\n      for (let j = 0; j < binCount; j += 1) {\n        const bin = bytes.readUInt32LE(currOffset)\n        if (bin > this.maxBinNumber) {\n          // this is a fake bin that actually has stats information\n          // about the reference sequence in it\n          stats = this.parsePseudoBin(bytes, currOffset + 4)\n          currOffset += 4 + 8 + 4 + 16 + 16\n        } else {\n          const loffset = fromBytes(bytes, currOffset + 4)\n          this._findFirstData(data, loffset)\n          const chunkCount = bytes.readInt32LE(currOffset + 12)\n          currOffset += 16\n          const chunks = new Array(chunkCount)\n          for (let k = 0; k < chunkCount; k += 1) {\n            const u = fromBytes(bytes, currOffset)\n            const v = fromBytes(bytes, currOffset + 8)\n            currOffset += 16\n            // this._findFirstData(data, u)\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          binIndex[bin] = chunks\n        }\n      }\n\n      data.indices[i] = { binIndex, stats }\n    }\n\n    return data\n  }\n\n  parsePseudoBin(bytes: Buffer, offset: number) {\n    // const one = Long.fromBytesLE(bytes.slice(offset + 4, offset + 12), true)\n    // const two = Long.fromBytesLE(bytes.slice(offset + 12, offset + 20), true)\n    // const three = longToNumber(\n    //   Long.fromBytesLE(bytes.slice(offset + 20, offset + 28), true),\n    // )\n    const lineCount = longToNumber(\n      Long.fromBytesLE(Array.prototype.slice.call(bytes, offset + 28, offset + 36), true),\n    )\n    return { lineCount }\n  }\n\n  async blocksForRange(refId: number, min: number, max: number, opts: BaseOpts = {}) {\n    if (min < 0) {\n      min = 0\n    }\n\n    const indexData = await this.parse(opts)\n    if (!indexData) {\n      return []\n    }\n    const ba = indexData.indices[refId]\n    if (!ba) {\n      return []\n    }\n\n    const overlappingBins = this.reg2bins(min, max) // List of bin #s that overlap min, max\n    const chunks: Chunk[] = []\n\n    // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n    for (const [start, end] of overlappingBins) {\n      for (let bin = start; bin <= end; bin++) {\n        if (ba.binIndex[bin]) {\n          const binChunks = ba.binIndex[bin]\n          for (let c = 0; c < binChunks.length; ++c) {\n            chunks.push(new Chunk(binChunks[c].minv, binChunks[c].maxv, bin))\n          }\n        }\n      }\n    }\n\n    return optimizeChunks(chunks, new VirtualOffset(0, 0))\n  }\n\n  /**\n   * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)\n   * @returns {Array[number]}\n   */\n  reg2bins(beg: number, end: number) {\n    beg -= 1 // < convert to 1-based closed\n    if (beg < 1) {\n      beg = 1\n    }\n    if (end > 2 ** 50) {\n      end = 2 ** 34\n    } // 17 GiB ought to be enough for anybody\n    end -= 1\n    let l = 0\n    let t = 0\n    let s = this.minShift + this.depth * 3\n    const bins = []\n    for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {\n      const b = t + rshift(beg, s)\n      const e = t + rshift(end, s)\n      if (e - b + bins.length > this.maxBinNumber) {\n        throw new Error(\n          `query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`,\n        )\n      }\n      bins.push([b, e])\n    }\n    return bins\n  }\n}\n","var _Object$getOwnPropertyDescriptor = require(\"../core-js/object/get-own-property-descriptor\");\n\nvar _Object$defineProperty = require(\"../core-js/object/define-property\");\n\nvar _typeof = require(\"../helpers/typeof\");\n\nvar _WeakMap = require(\"../core-js/weak-map\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof _WeakMap !== \"function\") return null;\n  var cache = new _WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = _Object$defineProperty && _Object$getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? _Object$getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        _Object$defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nmodule.exports = _interopRequireWildcard;","import AbortablePromiseCache from 'abortable-promise-cache'\nimport BAI from './bai'\nimport CSI from './csi'\nimport Chunk from './chunk'\nimport crc32 from 'buffer-crc32'\n\nimport { unzip, unzipChunkSlice } from '@gmod/bgzf-filehandle'\n\nimport entries from 'object.entries-ponyfill'\nimport LRU from 'quick-lru'\nimport { LocalFile, RemoteFile, GenericFilehandle } from 'generic-filehandle'\nimport BAMFeature from './record'\nimport IndexFile from './indexFile'\nimport { parseHeaderText } from './sam'\nimport { abortBreakPoint, checkAbortSignal, timeout, makeOpts, BamOpts, BaseOpts } from './util'\n\nexport const BAM_MAGIC = 21840194\n\nconst blockLen = 1 << 16\n\nexport default class BamFile {\n  private renameRefSeq: (a: string) => string\n  private bam: GenericFilehandle\n  private index: IndexFile\n  private chunkSizeLimit: number\n  private fetchSizeLimit: number\n  private header: any\n  protected featureCache: any\n  protected chrToIndex: any\n  protected indexToChr: any\n  private yieldThreadTime: number\n\n  /**\n   * @param {object} args\n   * @param {string} [args.bamPath]\n   * @param {FileHandle} [args.bamFilehandle]\n   * @param {string} [args.baiPath]\n   * @param {FileHandle} [args.baiFilehandle]\n   */\n  constructor({\n    bamFilehandle,\n    bamPath,\n    bamUrl,\n    baiPath,\n    baiFilehandle,\n    baiUrl,\n    csiPath,\n    csiFilehandle,\n    csiUrl,\n    cacheSize,\n    fetchSizeLimit,\n    chunkSizeLimit,\n    yieldThreadTime = 100,\n    renameRefSeqs = n => n,\n  }: {\n    bamFilehandle?: GenericFilehandle\n    bamPath?: string\n    bamUrl?: string\n    baiPath?: string\n    baiFilehandle?: GenericFilehandle\n    baiUrl?: string\n    csiPath?: string\n    csiFilehandle?: GenericFilehandle\n    csiUrl?: string\n    cacheSize?: number\n    fetchSizeLimit?: number\n    chunkSizeLimit?: number\n    renameRefSeqs?: (a: string) => string\n    yieldThreadTime?: number\n  }) {\n    this.renameRefSeq = renameRefSeqs\n\n    if (bamFilehandle) {\n      this.bam = bamFilehandle\n    } else if (bamPath) {\n      this.bam = new LocalFile(bamPath)\n    } else if (bamUrl) {\n      this.bam = new RemoteFile(bamUrl)\n    } else {\n      throw new Error('unable to initialize bam')\n    }\n    if (csiFilehandle) {\n      this.index = new CSI({ filehandle: csiFilehandle })\n    } else if (csiPath) {\n      this.index = new CSI({ filehandle: new LocalFile(csiPath) })\n    } else if (csiUrl) {\n      this.index = new CSI({ filehandle: new RemoteFile(csiUrl) })\n    } else if (baiFilehandle) {\n      this.index = new BAI({ filehandle: baiFilehandle })\n    } else if (baiPath) {\n      this.index = new BAI({ filehandle: new LocalFile(baiPath) })\n    } else if (baiUrl) {\n      this.index = new BAI({ filehandle: new RemoteFile(baiUrl) })\n    } else if (bamPath) {\n      this.index = new BAI({ filehandle: new LocalFile(`${bamPath}.bai`) })\n    } else if (bamUrl) {\n      this.index = new BAI({ filehandle: new RemoteFile(`${bamUrl}.bai`) })\n    } else {\n      throw new Error('unable to infer index format')\n    }\n    this.featureCache = new AbortablePromiseCache({\n      cache: new LRU({\n        maxSize: cacheSize !== undefined ? cacheSize : 50,\n      }),\n      fill: this._readChunk.bind(this),\n    })\n    this.fetchSizeLimit = fetchSizeLimit || 500000000 // 500MB\n    this.chunkSizeLimit = chunkSizeLimit || 300000000 // 300MB\n    this.yieldThreadTime = yieldThreadTime\n  }\n\n  async getHeader(origOpts: AbortSignal | BaseOpts = {}) {\n    const opts = makeOpts(origOpts)\n    const indexData = await this.index.parse(opts)\n    const ret = indexData.firstDataLine ? indexData.firstDataLine.blockPosition + 65535 : undefined\n    let buffer\n    if (ret) {\n      const res = await this.bam.read(Buffer.alloc(ret + blockLen), 0, ret + blockLen, 0, opts)\n\n      const { bytesRead } = res\n      ;({ buffer } = res)\n      if (!bytesRead) {\n        throw new Error('Error reading header')\n      }\n      if (bytesRead < ret) {\n        buffer = buffer.slice(0, bytesRead)\n      } else {\n        buffer = buffer.slice(0, ret)\n      }\n    } else {\n      buffer = (await this.bam.readFile(opts)) as Buffer\n    }\n\n    const uncba = await unzip(buffer)\n\n    if (uncba.readInt32LE(0) !== BAM_MAGIC) {\n      throw new Error('Not a BAM file')\n    }\n    const headLen = uncba.readInt32LE(4)\n\n    this.header = uncba.toString('utf8', 8, 8 + headLen)\n    const { chrToIndex, indexToChr } = await this._readRefSeqs(headLen + 8, 65535, opts)\n    this.chrToIndex = chrToIndex\n    this.indexToChr = indexToChr\n\n    return parseHeaderText(this.header)\n  }\n\n  async getHeaderText(opts: BaseOpts = {}) {\n    await this.getHeader(opts)\n    return this.header\n  }\n\n  // the full length of the refseq block is not given in advance so this grabs a chunk and\n  // doubles it if all refseqs haven't been processed\n  async _readRefSeqs(\n    start: number,\n    refSeqBytes: number,\n    opts: BaseOpts = {},\n  ): Promise<{\n    chrToIndex: { [key: string]: number }\n    indexToChr: { refName: string; length: number }[]\n  }> {\n    if (start > refSeqBytes) {\n      return this._readRefSeqs(start, refSeqBytes * 2, opts)\n    }\n    const res = await this.bam.read(Buffer.alloc(refSeqBytes + blockLen), 0, refSeqBytes, 0, opts)\n    const { bytesRead } = res\n    let { buffer } = res\n    if (!bytesRead) {\n      throw new Error('Error reading refseqs from header')\n    }\n    if (bytesRead < refSeqBytes) {\n      buffer = buffer.slice(0, bytesRead)\n    } else {\n      buffer = buffer.slice(0, refSeqBytes)\n    }\n    const uncba = await unzip(buffer)\n    const nRef = uncba.readInt32LE(start)\n    let p = start + 4\n    const chrToIndex: { [key: string]: number } = {}\n    const indexToChr: { refName: string; length: number }[] = []\n    for (let i = 0; i < nRef; i += 1) {\n      await abortBreakPoint(opts.signal)\n      const lName = uncba.readInt32LE(p)\n      let refName = uncba.toString('utf8', p + 4, p + 4 + lName - 1)\n      refName = this.renameRefSeq(refName)\n      const lRef = uncba.readInt32LE(p + lName + 4)\n\n      chrToIndex[refName] = i\n      indexToChr.push({ refName, length: lRef })\n\n      p = p + 8 + lName\n      if (p > uncba.length) {\n        console.warn(`BAM header is very big.  Re-fetching ${refSeqBytes} bytes.`)\n        return this._readRefSeqs(start, refSeqBytes * 2, opts)\n      }\n    }\n    return { chrToIndex, indexToChr }\n  }\n\n  async getRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts: BamOpts = { viewAsPairs: false, pairAcrossChr: false, maxInsertSize: 200000 },\n  ) {\n    let records: BAMFeature[] = []\n    for await (const chunk of this.streamRecordsForRange(chr, min, max, opts)) {\n      records = records.concat(chunk)\n    }\n    return records\n  }\n\n  async *streamRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts: BamOpts = { viewAsPairs: false, pairAcrossChr: false, maxInsertSize: 200000 },\n  ) {\n    // todo regularize refseq names\n    opts.viewAsPairs = opts.viewAsPairs || false\n    opts.pairAcrossChr = opts.pairAcrossChr || false\n    opts.maxInsertSize = opts.maxInsertSize !== undefined ? opts.maxInsertSize : 200000\n    const chrId = this.chrToIndex && this.chrToIndex[chr]\n    let chunks: Chunk[]\n    if (!(chrId >= 0)) {\n      chunks = []\n    } else {\n      chunks = await this.index.blocksForRange(chrId, min - 1, max, opts)\n\n      if (!chunks) {\n        throw new Error('Error in index fetch')\n      }\n    }\n\n    for (let i = 0; i < chunks.length; i += 1) {\n      await abortBreakPoint(opts.signal)\n      const size = chunks[i].fetchedSize()\n      if (size > this.chunkSizeLimit) {\n        throw new Error(\n          `Too many BAM features. BAM chunk size ${size} bytes exceeds chunkSizeLimit of ${this.chunkSizeLimit}`,\n        )\n      }\n    }\n\n    const totalSize = chunks\n      .map((s: Chunk) => s.fetchedSize())\n      .reduce((a: number, b: number) => a + b, 0)\n    if (totalSize > this.fetchSizeLimit) {\n      throw new Error(\n        `data size of ${totalSize.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`,\n      )\n    }\n    yield* this._fetchChunkFeatures(chunks, chrId, min, max, opts)\n  }\n\n  async *_fetchChunkFeatures(\n    chunks: Chunk[],\n    chrId: number,\n    min: number,\n    max: number,\n    opts: BamOpts,\n  ) {\n    const featPromises = []\n    let done = false\n\n    for (let i = 0; i < chunks.length; i++) {\n      const c = chunks[i]\n      const { data, cpositions, dpositions, chunk } = await this.featureCache.get(\n        c.toString(),\n        { chunk: c, opts },\n        opts.signal,\n      )\n      const promise = this.readBamFeatures(data, cpositions, dpositions, chunk).then(records => {\n        const recs = []\n        for (let i = 0; i < records.length; i += 1) {\n          const feature = records[i]\n          if (feature.seq_id() === chrId) {\n            if (feature.get('start') >= max) {\n              // past end of range, can stop iterating\n              done = true\n              break\n            } else if (feature.get('end') >= min) {\n              // must be in range\n              recs.push(feature)\n            }\n          }\n        }\n        return recs\n      })\n      featPromises.push(promise)\n      await promise\n      if (done) {\n        break\n      }\n    }\n\n    checkAbortSignal(opts.signal)\n\n    for (let i = 0; i < featPromises.length; i++) {\n      yield featPromises[i]\n    }\n    checkAbortSignal(opts.signal)\n    if (opts.viewAsPairs) {\n      yield this.fetchPairs(chrId, featPromises, opts)\n    }\n  }\n\n  async fetchPairs(chrId: number, featPromises: Promise<BAMFeature[]>[], opts: BamOpts) {\n    const unmatedPairs: { [key: string]: boolean } = {}\n    const readIds: { [key: string]: number } = {}\n    await Promise.all(\n      featPromises.map(async f => {\n        const ret = await f\n        const readNames: { [key: string]: number } = {}\n        for (let i = 0; i < ret.length; i++) {\n          const name = ret[i].name()\n          const id = ret[i].id()\n          if (!readNames[name]) {\n            readNames[name] = 0\n          }\n          readNames[name]++\n          readIds[id] = 1\n        }\n        entries(readNames).forEach(([k, v]: [string, number]) => {\n          if (v === 1) {\n            unmatedPairs[k] = true\n          }\n        })\n      }),\n    )\n\n    const matePromises: Promise<Chunk[]>[] = []\n    await Promise.all(\n      featPromises.map(async f => {\n        const ret = await f\n        for (let i = 0; i < ret.length; i++) {\n          const name = ret[i].name()\n          if (\n            unmatedPairs[name] &&\n            (opts.pairAcrossChr ||\n              (ret[i]._next_refid() === chrId &&\n                Math.abs(ret[i].get('start') - ret[i]._next_pos()) <\n                  (opts.maxInsertSize || 200000)))\n          ) {\n            matePromises.push(\n              this.index.blocksForRange(\n                ret[i]._next_refid(),\n                ret[i]._next_pos(),\n                ret[i]._next_pos() + 1,\n                opts,\n              ),\n            )\n          }\n        }\n      }),\n    )\n\n    const mateBlocks = await Promise.all(matePromises)\n    let mateChunks: Chunk[] = []\n    for (let i = 0; i < mateBlocks.length; i++) {\n      mateChunks = mateChunks.concat(mateBlocks[i])\n    }\n    // filter out duplicate chunks (the blocks are lists of chunks, blocks are concatenated, then filter dup chunks)\n    mateChunks = mateChunks\n      .sort()\n      .filter((item, pos, ary) => !pos || item.toString() !== ary[pos - 1].toString())\n\n    const mateTotalSize = mateChunks.map(s => s.fetchedSize()).reduce((a, b) => a + b, 0)\n    if (mateTotalSize > this.fetchSizeLimit) {\n      throw new Error(\n        `data size of ${mateTotalSize.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`,\n      )\n    }\n    const mateFeatPromises = mateChunks.map(async c => {\n      const { data, cpositions, dpositions, chunk } = await this.featureCache.get(\n        c.toString(),\n        { chunk: c, opts },\n        opts.signal,\n      )\n      const feats = await this.readBamFeatures(data, cpositions, dpositions, chunk)\n      const mateRecs = []\n      for (let i = 0; i < feats.length; i += 1) {\n        const feature = feats[i]\n        if (unmatedPairs[feature.get('name')] && !readIds[feature.id()]) {\n          mateRecs.push(feature)\n        }\n      }\n      return mateRecs\n    })\n    const newMateFeats = await Promise.all(mateFeatPromises)\n    let featuresRet: BAMFeature[] = []\n    if (newMateFeats.length) {\n      const newMates = newMateFeats.reduce((result, current) => result.concat(current))\n      featuresRet = featuresRet.concat(newMates)\n    }\n    return featuresRet\n  }\n\n  async _readChunk({ chunk, opts }: { chunk: unknown; opts: BaseOpts }, abortSignal?: AbortSignal) {\n    const c = chunk as Chunk\n    const bufsize = c.fetchedSize()\n    const res = await this.bam.read(Buffer.alloc(bufsize), 0, bufsize, c.minv.blockPosition, opts)\n    const { bytesRead } = res\n    let { buffer } = res\n    checkAbortSignal(abortSignal)\n    if (!bytesRead) {\n      return []\n    }\n    if (bytesRead < bufsize) {\n      buffer = buffer.slice(0, bytesRead)\n    } else {\n      buffer = buffer.slice(0, bufsize)\n    }\n\n    const { buffer: data, cpositions, dpositions } = await unzipChunkSlice(buffer, chunk)\n    checkAbortSignal(abortSignal)\n    return { data, cpositions, dpositions, chunk }\n  }\n\n  async readBamFeatures(ba: Buffer, cpositions: number[], dpositions: number[], chunk: Chunk) {\n    let blockStart = 0\n    const sink = []\n    let pos = 0\n    let last = +Date.now()\n\n    while (blockStart + 4 < ba.length) {\n      const blockSize = ba.readInt32LE(blockStart)\n      const blockEnd = blockStart + 4 + blockSize - 1\n\n      // increment position to the current decompressed status\n      if (dpositions) {\n        while (blockStart + chunk.minv.dataPosition >= dpositions[pos++]) {}\n        pos--\n      }\n\n      // only try to read the feature if we have all the bytes for it\n      if (blockEnd < ba.length) {\n        const feature = new BAMFeature({\n          bytes: {\n            byteArray: ba,\n            start: blockStart,\n            end: blockEnd,\n          },\n          // the below results in an automatically calculated file-offset based ID\n          // if the info for that is available, otherwise crc32 of the features\n          //\n          // cpositions[pos] refers to actual file offset of a bgzip block boundaries\n          //\n          // we multiply by (1 <<8) in order to make sure each block has a \"unique\"\n          // address space so that data in that block could never overlap\n          //\n          // then the blockStart-dpositions is an uncompressed file offset from\n          // that bgzip block boundary, and since the cpositions are multiplied by\n          // (1 << 8) these uncompressed offsets get a unique space\n          //\n          // this has an extra chunk.minv.dataPosition added on because it blockStart\n          // starts at 0 instead of chunk.minv.dataPosition\n          //\n          // the +1 is just to avoid any possible uniqueId 0 but this does not realistically happen\n          fileOffset: cpositions\n            ? cpositions[pos] * (1 << 8) +\n              (blockStart - dpositions[pos]) +\n              chunk.minv.dataPosition +\n              1\n            : crc32.signed(ba.slice(blockStart, blockEnd)),\n        })\n\n        sink.push(feature)\n        if (this.yieldThreadTime && +Date.now() - last > this.yieldThreadTime) {\n          await timeout(1)\n          last = +Date.now()\n        }\n      }\n\n      blockStart = blockEnd + 1\n    }\n    return sink\n  }\n\n  async hasRefSeq(seqName: string) {\n    const refId = this.chrToIndex && this.chrToIndex[seqName]\n    return this.index.hasRefSeq(refId)\n  }\n\n  async lineCount(seqName: string) {\n    const refId = this.chrToIndex && this.chrToIndex[seqName]\n    return this.index.lineCount(refId)\n  }\n\n  async indexCov(seqName: string, start?: number, end?: number) {\n    await this.index.parse()\n    const seqId = this.chrToIndex && this.chrToIndex[seqName]\n    return this.index.indexCov(seqId, start, end)\n  }\n}\n","var AsyncGenerator = require(\"./AsyncGenerator\");\n\nfunction _wrapAsyncGenerator(fn) {\n  return function () {\n    return new AsyncGenerator(fn.apply(this, arguments));\n  };\n}\n\nmodule.exports = _wrapAsyncGenerator;","module.exports = require(\"core-js-pure/features/symbol/async-iterator\");","function _AwaitValue(value) {\n  this.wrapped = value;\n}\n\nmodule.exports = _AwaitValue;","var AwaitValue = require(\"./AwaitValue\");\n\nfunction _awaitAsyncGenerator(value) {\n  return new AwaitValue(value);\n}\n\nmodule.exports = _awaitAsyncGenerator;","var _Symbol$iterator = require(\"../core-js/symbol/iterator\");\n\nvar _Symbol = require(\"../core-js/symbol\");\n\nvar _Promise = require(\"../core-js/promise\");\n\nfunction _asyncGeneratorDelegate(inner, awaitWrap) {\n  var iter = {},\n      waiting = false;\n\n  function pump(key, value) {\n    waiting = true;\n    value = new _Promise(function (resolve) {\n      resolve(inner[key](value));\n    });\n    return {\n      done: false,\n      value: awaitWrap(value)\n    };\n  }\n\n  ;\n\n  if (typeof _Symbol === \"function\" && _Symbol$iterator) {\n    iter[_Symbol$iterator] = function () {\n      return this;\n    };\n  }\n\n  iter.next = function (value) {\n    if (waiting) {\n      waiting = false;\n      return value;\n    }\n\n    return pump(\"next\", value);\n  };\n\n  if (typeof inner[\"throw\"] === \"function\") {\n    iter[\"throw\"] = function (value) {\n      if (waiting) {\n        waiting = false;\n        throw value;\n      }\n\n      return pump(\"throw\", value);\n    };\n  }\n\n  if (typeof inner[\"return\"] === \"function\") {\n    iter[\"return\"] = function (value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n\n      return pump(\"return\", value);\n    };\n  }\n\n  return iter;\n}\n\nmodule.exports = _asyncGeneratorDelegate;","var _getIteratorMethod = require(\"../core-js/get-iterator-method\");\n\nvar _Symbol$iterator = require(\"../core-js/symbol/iterator\");\n\nvar _Symbol$asyncIterator = require(\"../core-js/symbol/async-iterator\");\n\nvar _Symbol = require(\"../core-js/symbol\");\n\nfunction _asyncIterator(iterable) {\n  var method;\n\n  if (typeof _Symbol !== \"undefined\") {\n    if (_Symbol$asyncIterator) {\n      method = iterable[_Symbol$asyncIterator];\n      if (method != null) return method.call(iterable);\n    }\n\n    if (_Symbol$iterator) {\n      method = _getIteratorMethod(iterable);\n      if (method != null) return method.call(iterable);\n    }\n  }\n\n  throw new TypeError(\"Object is not async iterable\");\n}\n\nmodule.exports = _asyncIterator;","/* eslint-disable @typescript-eslint/camelcase */\n/* eslint-disable @typescript-eslint/no-empty-function */\nimport Constants from './constants'\n\nconst SEQRET_DECODER = '=ACMGRSVTWYHKDBN'.split('').map(s => s.charCodeAt(0))\nconst CIGAR_DECODER = 'MIDNSHP=X???????'.split('')\n\n/**\n * Class of each BAM record returned by this API.\n */\nexport default class BamRecord {\n  private data: any\n  private bytes: any\n  private flags: any\n  private _id: number\n  private _refID: number\n  private _tagOffset: number | undefined = undefined\n  private _tagList: string[] = []\n  private _allTagsParsed = false\n  constructor(args: any) {\n    this.data = {}\n    this.bytes = {\n      start: args.bytes.start,\n      end: args.bytes.end,\n      byteArray: args.bytes.byteArray,\n    }\n    this._id = args.fileOffset\n    const { start, byteArray } = this.bytes\n    this._refID = byteArray.readInt32LE(start + 4)\n    this.data.start = byteArray.readInt32LE(start + 8)\n    this.flags = (byteArray.readInt32LE(start + 16) & 0xffff0000) >> 16\n  }\n\n  get(field: string) {\n    //@ts-ignore\n    if (this[field]) {\n      //@ts-ignore\n      if (this.data[field]) {\n        return this.data[field]\n      }\n      //@ts-ignore\n      this.data[field] = this[field]()\n      return this.data[field]\n    }\n    return this._get(field.toLowerCase())\n  }\n\n  end() {\n    return this.get('start') + (this.get('length_on_ref') || this.get('seq_length') || undefined)\n  }\n\n  seq_id() {\n    return this._refID\n  }\n\n  // same as get(), except requires lower-case arguments.  used\n  // internally to save lots of calls to field.toLowerCase()\n  _get(field: string) {\n    if (field in this.data) {\n      return this.data[field]\n    }\n    this.data[field] = this._parseTag(field)\n    return this.data[field]\n  }\n\n  _tags() {\n    this._parseAllTags()\n\n    let tags = ['seq']\n\n    if (!this.isSegmentUnmapped()) {\n      tags.push(\n        'start',\n        'end',\n        'strand',\n        'score',\n        'qual',\n        'MQ',\n        'CIGAR',\n        'length_on_ref',\n        'template_length',\n      )\n    }\n    if (this.isPaired()) {\n      tags.push('next_segment_position', 'pair_orientation')\n    }\n    tags = tags.concat(this._tagList || [])\n\n    Object.keys(this.data).forEach(k => {\n      if (k[0] !== '_' && k !== 'next_seq_id') {\n        tags.push(k)\n      }\n    })\n\n    const seen: { [key: string]: boolean } = {}\n    tags = tags.filter(t => {\n      if ((t in this.data && this.data[t] === undefined) || t === 'CG' || t === 'cg') {\n        return false\n      }\n\n      const lt = t.toLowerCase()\n      const s = seen[lt]\n      seen[lt] = true\n      return !s\n    })\n\n    return tags\n  }\n\n  parent() {\n    return undefined\n  }\n\n  children() {\n    return this.get('subfeatures')\n  }\n\n  id() {\n    return this._id\n  }\n\n  // special parsers\n  /**\n   * Mapping quality score.\n   */\n  mq() {\n    const mq = (this.get('_bin_mq_nl') & 0xff00) >> 8\n    return mq === 255 ? undefined : mq\n  }\n\n  score() {\n    return this.get('mq')\n  }\n\n  qual() {\n    return this.qualRaw()?.join(' ')\n  }\n\n  qualRaw() {\n    if (this.isSegmentUnmapped()) {\n      return undefined\n    }\n\n    const { byteArray } = this.bytes\n    const p =\n      this.bytes.start +\n      36 +\n      this.get('_l_read_name') +\n      this.get('_n_cigar_op') * 4 +\n      this.get('_seq_bytes')\n    const lseq = this.get('seq_length')\n    const qseq = Buffer.allocUnsafe(lseq)\n    for (let j = 0; j < lseq; ++j) {\n      qseq[j] = byteArray[p + j]\n    }\n    return qseq\n  }\n\n  strand() {\n    return this.isReverseComplemented() ? -1 : 1\n  }\n\n  multi_segment_next_segment_strand() {\n    if (this.isMateUnmapped()) {\n      return undefined\n    }\n    return this.isMateReverseComplemented() ? -1 : 1\n  }\n\n  name() {\n    return this.get('_read_name')\n  }\n\n  _read_name() {\n    const nl = this.get('_l_read_name')\n    return this.bytes.byteArray.toString(\n      'ascii',\n      this.bytes.start + 36,\n      this.bytes.start + 36 + nl - 1,\n    )\n  }\n\n  /**\n   * Get the value of a tag, parsing the tags as far as necessary.\n   * Only called if we have not already parsed that field.\n   */\n  _parseTag(tagName?: string) {\n    // if all of the tags have been parsed and we're still being\n    // called, we already know that we have no such tag, because\n    // it would already have been cached.\n    if (this._allTagsParsed) {\n      return undefined\n    }\n\n    const { byteArray } = this.bytes\n    let p =\n      this._tagOffset ||\n      this.bytes.start +\n        36 +\n        this.get('_l_read_name') +\n        this.get('_n_cigar_op') * 4 +\n        this.get('_seq_bytes') +\n        this.get('seq_length')\n\n    const blockEnd = this.bytes.end\n    let lcTag\n    while (p < blockEnd && lcTag !== tagName) {\n      const tag = String.fromCharCode(byteArray[p], byteArray[p + 1])\n      lcTag = tag.toLowerCase()\n      const type = String.fromCharCode(byteArray[p + 2])\n      p += 3\n\n      let value\n      switch (type) {\n        case 'A':\n          value = String.fromCharCode(byteArray[p])\n          p += 1\n          break\n        case 'i':\n          value = byteArray.readInt32LE(p)\n          p += 4\n          break\n        case 'I':\n          value = byteArray.readUInt32LE(p)\n          p += 4\n          break\n        case 'c':\n          value = byteArray.readInt8(p)\n          p += 1\n          break\n        case 'C':\n          value = byteArray.readUInt8(p)\n          p += 1\n          break\n        case 's':\n          value = byteArray.readInt16LE(p)\n          p += 2\n          break\n        case 'S':\n          value = byteArray.readUInt16LE(p)\n          p += 2\n          break\n        case 'f':\n          value = byteArray.readFloatLE(p)\n          p += 4\n          break\n        case 'Z':\n        case 'H':\n          value = ''\n          while (p <= blockEnd) {\n            const cc = byteArray[p++]\n            if (cc === 0) {\n              break\n            } else {\n              value += String.fromCharCode(cc)\n            }\n          }\n          break\n        case 'B': {\n          value = ''\n          const cc = byteArray[p++]\n          const Btype = String.fromCharCode(cc)\n          const limit = byteArray.readInt32LE(p)\n          p += 4\n          if (Btype === 'i') {\n            if (tag === 'CG') {\n              for (let k = 0; k < limit; k++) {\n                const cigop = byteArray.readInt32LE(p)\n                const lop = cigop >> 4\n                const op = CIGAR_DECODER[cigop & 0xf]\n                value += lop + op\n                p += 4\n              }\n            } else {\n              for (let k = 0; k < limit; k++) {\n                value += byteArray.readInt32LE(p)\n                if (k + 1 < limit) {\n                  value += ','\n                }\n                p += 4\n              }\n            }\n          }\n          if (Btype === 'I') {\n            if (tag === 'CG') {\n              for (let k = 0; k < limit; k++) {\n                const cigop = byteArray.readUInt32LE(p)\n                const lop = cigop >> 4\n                const op = CIGAR_DECODER[cigop & 0xf]\n                value += lop + op\n                p += 4\n              }\n            } else {\n              for (let k = 0; k < limit; k++) {\n                value += byteArray.readUInt32LE(p)\n                if (k + 1 < limit) {\n                  value += ','\n                }\n                p += 4\n              }\n            }\n          }\n          if (Btype === 's') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readInt16LE(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 2\n            }\n          }\n          if (Btype === 'S') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readUInt16LE(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 2\n            }\n          }\n          if (Btype === 'c') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readInt8(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 1\n            }\n          }\n          if (Btype === 'C') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readUInt8(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 1\n            }\n          }\n          if (Btype === 'f') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readFloatLE(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 4\n            }\n          }\n          break\n        }\n        default:\n          console.warn(`Unknown BAM tag type '${type}', tags may be incomplete`)\n          value = undefined\n          p = blockEnd // stop parsing tags\n      }\n\n      this._tagOffset = p\n\n      this._tagList.push(tag)\n      if (lcTag === tagName) {\n        return value\n      }\n\n      this.data[lcTag] = value\n    }\n    this._allTagsParsed = true\n    return undefined\n  }\n\n  _parseAllTags() {\n    this._parseTag('')\n  }\n\n  _parseCigar(cigar: string) {\n    return (\n      //@ts-ignore\n      cigar.match(/\\d+\\D/g).map((op: string) => [op.match(/\\D/)[0].toUpperCase(), parseInt(op, 10)])\n    )\n  }\n\n  /**\n   * @returns {boolean} true if the read is paired, regardless of whether both segments are mapped\n   */\n  isPaired() {\n    return !!(this.flags & Constants.BAM_FPAIRED)\n  }\n\n  /** @returns {boolean} true if the read is paired, and both segments are mapped */\n  isProperlyPaired() {\n    return !!(this.flags & Constants.BAM_FPROPER_PAIR)\n  }\n\n  /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n  isSegmentUnmapped() {\n    return !!(this.flags & Constants.BAM_FUNMAP)\n  }\n\n  /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n  isMateUnmapped() {\n    return !!(this.flags & Constants.BAM_FMUNMAP)\n  }\n\n  /** @returns {boolean} true if the read is mapped to the reverse strand */\n  isReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FREVERSE)\n  }\n\n  /** @returns {boolean} true if the mate is mapped to the reverse strand */\n  isMateReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FMREVERSE)\n  }\n\n  /** @returns {boolean} true if this is read number 1 in a pair */\n  isRead1() {\n    return !!(this.flags & Constants.BAM_FREAD1)\n  }\n\n  /** @returns {boolean} true if this is read number 2 in a pair */\n  isRead2() {\n    return !!(this.flags & Constants.BAM_FREAD2)\n  }\n\n  /** @returns {boolean} true if this is a secondary alignment */\n  isSecondary() {\n    return !!(this.flags & Constants.BAM_FSECONDARY)\n  }\n\n  /** @returns {boolean} true if this read has failed QC checks */\n  isFailedQc() {\n    return !!(this.flags & Constants.BAM_FQCFAIL)\n  }\n\n  /** @returns {boolean} true if the read is an optical or PCR duplicate */\n  isDuplicate() {\n    return !!(this.flags & Constants.BAM_FDUP)\n  }\n\n  /** @returns {boolean} true if this is a supplementary alignment */\n  isSupplementary() {\n    return !!(this.flags & Constants.BAM_FSUPPLEMENTARY)\n  }\n\n  cigar() {\n    if (this.isSegmentUnmapped()) {\n      return undefined\n    }\n\n    const { byteArray, start } = this.bytes\n    const numCigarOps = this.get('_n_cigar_op')\n    let p = start + 36 + this.get('_l_read_name')\n    const seqLen = this.get('seq_length')\n    let cigar = ''\n    let lref = 0\n\n    // check for CG tag by inspecting whether the CIGAR field\n    // contains a clip that consumes entire seqLen\n    let cigop = byteArray.readInt32LE(p)\n    let lop = cigop >> 4\n    let op = CIGAR_DECODER[cigop & 0xf]\n    if (op === 'S' && lop === seqLen) {\n      // if there is a CG the second CIGAR field will\n      // be a N tag the represents the length on ref\n      p += 4\n      cigop = byteArray.readInt32LE(p)\n      lop = cigop >> 4\n      op = CIGAR_DECODER[cigop & 0xf]\n      if (op !== 'N') {\n        console.warn('CG tag with no N tag')\n      }\n      this.data.length_on_ref = lop\n      return this.get('CG')\n    } else {\n      for (let c = 0; c < numCigarOps; ++c) {\n        cigop = byteArray.readInt32LE(p)\n        lop = cigop >> 4\n        op = CIGAR_DECODER[cigop & 0xf]\n        cigar += lop + op\n\n        // soft clip, hard clip, and insertion don't count toward\n        // the length on the reference\n        if (op !== 'H' && op !== 'S' && op !== 'I') {\n          lref += lop\n        }\n\n        p += 4\n      }\n\n      this.data.length_on_ref = lref\n      return cigar\n    }\n  }\n\n  _flags() {}\n\n  length_on_ref() {\n    this.get('cigar') // the length_on_ref is set as a\n    // side effect of the CIGAR parsing\n    return this.data.length_on_ref\n  }\n\n  _n_cigar_op() {\n    return this.get('_flag_nc') & 0xffff\n  }\n\n  _l_read_name() {\n    return this.get('_bin_mq_nl') & 0xff\n  }\n\n  /**\n   * number of bytes in the sequence field\n   */\n  _seq_bytes() {\n    return (this.get('seq_length') + 1) >> 1\n  }\n\n  getReadBases() {\n    return this.seq()\n  }\n\n  seq() {\n    const { byteArray } = this.bytes\n    const p = this.bytes.start + 36 + this.get('_l_read_name') + this.get('_n_cigar_op') * 4\n    const seqBytes = this.get('_seq_bytes')\n    const len = this.get('seq_length')\n    let buf = ''\n    let i = 0\n    for (let j = 0; j < seqBytes; ++j) {\n      const sb = byteArray[p + j]\n      buf += String.fromCharCode(SEQRET_DECODER[(sb & 0xf0) >> 4])\n      i++\n      if (i < len) {\n        buf += String.fromCharCode(SEQRET_DECODER[sb & 0x0f])\n        i++\n      }\n    }\n    return buf\n  }\n\n  // adapted from igv.js\n  getPairOrientation() {\n    if (!this.isSegmentUnmapped() && !this.isMateUnmapped() && this._refID === this._next_refid()) {\n      const s1 = this.isReverseComplemented() ? 'R' : 'F'\n      const s2 = this.isMateReverseComplemented() ? 'R' : 'F'\n      let o1 = ' '\n      let o2 = ' '\n      if (this.isRead1()) {\n        o1 = '1'\n        o2 = '2'\n      } else if (this.isRead2()) {\n        o1 = '2'\n        o2 = '1'\n      }\n\n      const tmp = []\n      const isize = this.template_length()\n      if (isize > 0) {\n        tmp[0] = s1\n        tmp[1] = o1\n        tmp[2] = s2\n        tmp[3] = o2\n      } else {\n        tmp[2] = s1\n        tmp[3] = o1\n        tmp[0] = s2\n        tmp[1] = o2\n      }\n      return tmp.join('')\n    }\n    return null\n  }\n\n  _bin_mq_nl() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 12)\n  }\n\n  _flag_nc() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 16)\n  }\n\n  seq_length() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 20)\n  }\n\n  _next_refid() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 24)\n  }\n\n  _next_pos() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 28)\n  }\n\n  template_length() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 32)\n  }\n\n  toJSON() {\n    const data: { [key: string]: any } = {}\n    Object.keys(this).forEach(k => {\n      if (k.charAt(0) === '_' || k === 'bytes') {\n        return\n      }\n      //@ts-ignore\n      data[k] = this[k]\n    })\n\n    return data\n  }\n}\n","export function parseHeaderText(text: string) {\n  const lines = text.split(/\\r?\\n/)\n  const data: { tag: string; data: { tag: string; value: string }[] }[] = []\n  lines.forEach(line => {\n    const [tag, ...fields] = line.split(/\\t/)\n    const parsedFields = fields.map(f => {\n      const [fieldTag, value] = f.split(':', 2)\n      return { tag: fieldTag, value }\n    })\n    if (tag) {\n      data.push({ tag: tag.substr(1), data: parsedFields })\n    }\n  })\n  return data\n}\n","module.exports = require(\"core-js-pure/stable/object/define-property\");","var parent = require('../../es/object/define-property');\n\nmodule.exports = parent;\n","var parent = require('../../es/array/is-array');\n\nmodule.exports = parent;\n","require('../modules/web.dom-collections.iterator');\nrequire('../modules/es.string.iterator');\nvar getIteratorMethod = require('../internals/get-iterator-method');\n\nmodule.exports = getIteratorMethod;\n","var parent = require('../../es/symbol');\n\nmodule.exports = parent;\n","var parent = require('../../es/array/from');\n\nmodule.exports = parent;\n","var parent = require('../../es/object/define-properties');\n\nmodule.exports = parent;\n","require('../../modules/es.object.define-properties');\nvar path = require('../../internals/path');\n\nvar Object = path.Object;\n\nvar defineProperties = module.exports = function defineProperties(T, D) {\n  return Object.defineProperties(T, D);\n};\n\nif (Object.defineProperties.sham) defineProperties.sham = true;\n","var $ = require('../internals/export');\nvar DESCRIPTORS = require('../internals/descriptors');\nvar defineProperties = require('../internals/object-define-properties');\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n$({ target: 'Object', stat: true, forced: !DESCRIPTORS, sham: !DESCRIPTORS }, {\n  defineProperties: defineProperties\n});\n","var parent = require('../../es/object/get-own-property-descriptors');\n\nmodule.exports = parent;\n","require('../../modules/es.object.get-own-property-descriptors');\nvar path = require('../../internals/path');\n\nmodule.exports = path.Object.getOwnPropertyDescriptors;\n","var $ = require('../internals/export');\nvar DESCRIPTORS = require('../internals/descriptors');\nvar ownKeys = require('../internals/own-keys');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');\nvar createProperty = require('../internals/create-property');\n\n// `Object.getOwnPropertyDescriptors` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors\n$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {\n    var O = toIndexedObject(object);\n    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n    var keys = ownKeys(O);\n    var result = {};\n    var index = 0;\n    var key, descriptor;\n    while (keys.length > index) {\n      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);\n      if (descriptor !== undefined) createProperty(result, key, descriptor);\n    }\n    return result;\n  }\n});\n","var getBuiltIn = require('../internals/get-built-in');\nvar getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar anObject = require('../internals/an-object');\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n","var parent = require('../../es/object/get-own-property-descriptor');\n\nmodule.exports = parent;\n","var $ = require('../internals/export');\nvar fails = require('../internals/fails');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar nativeGetOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar DESCRIPTORS = require('../internals/descriptors');\n\nvar FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor(1); });\nvar FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\n$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {\n    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);\n  }\n});\n","var parent = require('../../es/object/get-own-property-symbols');\n\nmodule.exports = parent;\n","var parent = require('../../es/reflect/construct');\n\nmodule.exports = parent;\n","module.exports = require(\"core-js-pure/stable/set-timeout\");","require('../modules/web.timers');\nvar path = require('../internals/path');\n\nmodule.exports = path.setTimeout;\n","var $ = require('../internals/export');\nvar global = require('../internals/global');\nvar userAgent = require('../internals/engine-user-agent');\n\nvar slice = [].slice;\nvar MSIE = /MSIE .\\./.test(userAgent); // <- dirty ie9- check\n\nvar wrap = function (scheduler) {\n  return function (handler, timeout /* , ...arguments */) {\n    var boundArgs = arguments.length > 2;\n    var args = boundArgs ? slice.call(arguments, 2) : undefined;\n    return scheduler(boundArgs ? function () {\n      // eslint-disable-next-line no-new-func -- spec requirement\n      (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);\n    } : handler, timeout);\n  };\n};\n\n// ie9- setTimeout & setInterval additional parameters fix\n// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers\n$({ global: true, bind: true, forced: MSIE }, {\n  // `setTimeout` method\n  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout\n  setTimeout: wrap(global.setTimeout),\n  // `setInterval` method\n  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval\n  setInterval: wrap(global.setInterval)\n});\n","module.exports = require(\"core-js-pure/features/object/get-own-property-descriptor\");","var parent = require('../../es/object/get-own-property-descriptor');\n\nmodule.exports = parent;\n","module.exports = require(\"core-js-pure/features/weak-map\");","var parent = require('../../es/weak-map');\nrequire('../../modules/esnext.weak-map.emplace');\nrequire('../../modules/esnext.weak-map.from');\nrequire('../../modules/esnext.weak-map.of');\nrequire('../../modules/esnext.weak-map.delete-all');\n// TODO: remove from `core-js@4`\nrequire('../../modules/esnext.weak-map.upsert');\n\nmodule.exports = parent;\n","require('../../modules/es.object.to-string');\nrequire('../../modules/es.weak-map');\nrequire('../../modules/web.dom-collections.iterator');\nvar path = require('../../internals/path');\n\nmodule.exports = path.WeakMap;\n","'use strict';\nvar global = require('../internals/global');\nvar redefineAll = require('../internals/redefine-all');\nvar InternalMetadataModule = require('../internals/internal-metadata');\nvar collection = require('../internals/collection');\nvar collectionWeak = require('../internals/collection-weak');\nvar isObject = require('../internals/is-object');\nvar enforceIternalState = require('../internals/internal-state').enforce;\nvar NATIVE_WEAK_MAP = require('../internals/native-weak-map');\n\nvar IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;\n// eslint-disable-next-line es/no-object-isextensible -- safe\nvar isExtensible = Object.isExtensible;\nvar InternalWeakMap;\n\nvar wrapper = function (init) {\n  return function WeakMap() {\n    return init(this, arguments.length ? arguments[0] : undefined);\n  };\n};\n\n// `WeakMap` constructor\n// https://tc39.es/ecma262/#sec-weakmap-constructor\nvar $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak);\n\n// IE11 WeakMap frozen keys fix\n// We can't use feature detection because it crash some old IE builds\n// https://github.com/zloirock/core-js/issues/485\nif (NATIVE_WEAK_MAP && IS_IE11) {\n  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);\n  InternalMetadataModule.REQUIRED = true;\n  var WeakMapPrototype = $WeakMap.prototype;\n  var nativeDelete = WeakMapPrototype['delete'];\n  var nativeHas = WeakMapPrototype.has;\n  var nativeGet = WeakMapPrototype.get;\n  var nativeSet = WeakMapPrototype.set;\n  redefineAll(WeakMapPrototype, {\n    'delete': function (key) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceIternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        return nativeDelete.call(this, key) || state.frozen['delete'](key);\n      } return nativeDelete.call(this, key);\n    },\n    has: function has(key) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceIternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        return nativeHas.call(this, key) || state.frozen.has(key);\n      } return nativeHas.call(this, key);\n    },\n    get: function get(key) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceIternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);\n      } return nativeGet.call(this, key);\n    },\n    set: function set(key, value) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceIternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);\n      } else nativeSet.call(this, key, value);\n      return this;\n    }\n  });\n}\n","'use strict';\nvar redefineAll = require('../internals/redefine-all');\nvar getWeakData = require('../internals/internal-metadata').getWeakData;\nvar anObject = require('../internals/an-object');\nvar isObject = require('../internals/is-object');\nvar anInstance = require('../internals/an-instance');\nvar iterate = require('../internals/iterate');\nvar ArrayIterationModule = require('../internals/array-iteration');\nvar $has = require('../internals/has');\nvar InternalStateModule = require('../internals/internal-state');\n\nvar setInternalState = InternalStateModule.set;\nvar internalStateGetterFor = InternalStateModule.getterFor;\nvar find = ArrayIterationModule.find;\nvar findIndex = ArrayIterationModule.findIndex;\nvar id = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function (store) {\n  return store.frozen || (store.frozen = new UncaughtFrozenStore());\n};\n\nvar UncaughtFrozenStore = function () {\n  this.entries = [];\n};\n\nvar findUncaughtFrozen = function (store, key) {\n  return find(store.entries, function (it) {\n    return it[0] === key;\n  });\n};\n\nUncaughtFrozenStore.prototype = {\n  get: function (key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) return entry[1];\n  },\n  has: function (key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function (key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) entry[1] = value;\n    else this.entries.push([key, value]);\n  },\n  'delete': function (key) {\n    var index = findIndex(this.entries, function (it) {\n      return it[0] === key;\n    });\n    if (~index) this.entries.splice(index, 1);\n    return !!~index;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, CONSTRUCTOR_NAME);\n      setInternalState(that, {\n        type: CONSTRUCTOR_NAME,\n        id: id++,\n        frozen: undefined\n      });\n      if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });\n    });\n\n    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n\n    var define = function (that, key, value) {\n      var state = getInternalState(that);\n      var data = getWeakData(anObject(key), true);\n      if (data === true) uncaughtFrozenStore(state).set(key, value);\n      else data[state.id] = value;\n      return that;\n    };\n\n    redefineAll(C.prototype, {\n      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete\n      // https://tc39.es/ecma262/#sec-weakset.prototype.delete\n      'delete': function (key) {\n        var state = getInternalState(this);\n        if (!isObject(key)) return false;\n        var data = getWeakData(key);\n        if (data === true) return uncaughtFrozenStore(state)['delete'](key);\n        return data && $has(data, state.id) && delete data[state.id];\n      },\n      // `{ WeakMap, WeakSet }.prototype.has(key)` methods\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.has\n      // https://tc39.es/ecma262/#sec-weakset.prototype.has\n      has: function has(key) {\n        var state = getInternalState(this);\n        if (!isObject(key)) return false;\n        var data = getWeakData(key);\n        if (data === true) return uncaughtFrozenStore(state).has(key);\n        return data && $has(data, state.id);\n      }\n    });\n\n    redefineAll(C.prototype, IS_MAP ? {\n      // `WeakMap.prototype.get(key)` method\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.get\n      get: function get(key) {\n        var state = getInternalState(this);\n        if (isObject(key)) {\n          var data = getWeakData(key);\n          if (data === true) return uncaughtFrozenStore(state).get(key);\n          return data ? data[state.id] : undefined;\n        }\n      },\n      // `WeakMap.prototype.set(key, value)` method\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.set\n      set: function set(key, value) {\n        return define(this, key, value);\n      }\n    } : {\n      // `WeakSet.prototype.add(value)` method\n      // https://tc39.es/ecma262/#sec-weakset.prototype.add\n      add: function add(value) {\n        return define(this, value, true);\n      }\n    });\n\n    return C;\n  }\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar $emplace = require('../internals/map-emplace');\n\n// `WeakMap.prototype.emplace` method\n// https://github.com/tc39/proposal-upsert\n$({ target: 'WeakMap', proto: true, real: true, forced: IS_PURE }, {\n  emplace: $emplace\n});\n","var $ = require('../internals/export');\nvar from = require('../internals/collection-from');\n\n// `WeakMap.from` method\n// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from\n$({ target: 'WeakMap', stat: true }, {\n  from: from\n});\n","var $ = require('../internals/export');\nvar of = require('../internals/collection-of');\n\n// `WeakMap.of` method\n// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of\n$({ target: 'WeakMap', stat: true }, {\n  of: of\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar collectionDeleteAll = require('../internals/collection-delete-all');\n\n// `WeakMap.prototype.deleteAll` method\n// https://github.com/tc39/proposal-collection-methods\n$({ target: 'WeakMap', proto: true, real: true, forced: IS_PURE }, {\n  deleteAll: function deleteAll(/* ...elements */) {\n    return collectionDeleteAll.apply(this, arguments);\n  }\n});\n","'use strict';\n// TODO: remove from `core-js@4`\nvar $ = require('../internals/export');\nvar IS_PURE = require('../internals/is-pure');\nvar $upsert = require('../internals/map-upsert');\n\n// `WeakMap.prototype.upsert` method (replaced by `WeakMap.prototype.emplace`)\n// https://github.com/tc39/proposal-upsert\n$({ target: 'WeakMap', proto: true, real: true, forced: IS_PURE }, {\n  upsert: $upsert\n});\n","module.exports = require(\"core-js-pure/stable/date/now\");","var parent = require('../../es/date/now');\n\nmodule.exports = parent;\n","require('../../modules/es.date.now');\nvar path = require('../../internals/path');\n\nmodule.exports = path.Date.now;\n","var $ = require('../internals/export');\n\n// `Date.now` method\n// https://tc39.es/ecma262/#sec-date.now\n$({ target: 'Date', stat: true }, {\n  now: function now() {\n    return new Date().getTime();\n  }\n});\n","var _Symbol$asyncIterator = require(\"../core-js/symbol/async-iterator\");\n\nvar _Symbol = require(\"../core-js/symbol\");\n\nvar _Promise = require(\"../core-js/promise\");\n\nvar AwaitValue = require(\"./AwaitValue\");\n\nfunction AsyncGenerator(gen) {\n  var front, back;\n\n  function send(key, arg) {\n    return new _Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n\n      if (back) {\n        back = back.next = request;\n      } else {\n        front = back = request;\n        resume(key, arg);\n      }\n    });\n  }\n\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg);\n      var value = result.value;\n      var wrappedAwait = value instanceof AwaitValue;\n\n      _Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {\n        if (wrappedAwait) {\n          resume(key === \"return\" ? \"return\" : \"next\", arg);\n          return;\n        }\n\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: true\n        });\n        break;\n\n      case \"throw\":\n        front.reject(value);\n        break;\n\n      default:\n        front.resolve({\n          value: value,\n          done: false\n        });\n        break;\n    }\n\n    front = front.next;\n\n    if (front) {\n      resume(front.key, front.arg);\n    } else {\n      back = null;\n    }\n  }\n\n  this._invoke = send;\n\n  if (typeof gen[\"return\"] !== \"function\") {\n    this[\"return\"] = undefined;\n  }\n}\n\nif (typeof _Symbol === \"function\" && _Symbol$asyncIterator) {\n  AsyncGenerator.prototype[_Symbol$asyncIterator] = function () {\n    return this;\n  };\n}\n\nAsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n};\n\nAsyncGenerator.prototype[\"throw\"] = function (arg) {\n  return this._invoke(\"throw\", arg);\n};\n\nAsyncGenerator.prototype[\"return\"] = function (arg) {\n  return this._invoke(\"return\", arg);\n};\n\nmodule.exports = AsyncGenerator;","var parent = require('../../es/symbol/async-iterator');\n\nmodule.exports = parent;\n","require('../../modules/es.symbol.async-iterator');\nvar WrappedWellKnownSymbolModule = require('../../internals/well-known-symbol-wrapped');\n\nmodule.exports = WrappedWellKnownSymbolModule.f('asyncIterator');\n","export default {\n  //  the read is paired in sequencing, no matter whether it is mapped in a pair\n  BAM_FPAIRED: 1,\n  //  the read is mapped in a proper pair\n  BAM_FPROPER_PAIR: 2,\n  //  the read itself is unmapped; conflictive with BAM_FPROPER_PAIR\n  BAM_FUNMAP: 4,\n  //  the mate is unmapped\n  BAM_FMUNMAP: 8,\n  //  the read is mapped to the reverse strand\n  BAM_FREVERSE: 16,\n  //  the mate is mapped to the reverse strand\n  BAM_FMREVERSE: 32,\n  //  this is read1\n  BAM_FREAD1: 64,\n  //  this is read2\n  BAM_FREAD2: 128,\n  //  not primary alignment\n  BAM_FSECONDARY: 256,\n  //  QC failure\n  BAM_FQCFAIL: 512,\n  //  optical or PCR duplicate\n  BAM_FDUP: 1024,\n  //  supplementary alignment\n  BAM_FSUPPLEMENTARY: 2048,\n}\n","import { BaseOpts, BamOpts } from './util'\nimport BamFile, { BAM_MAGIC } from './bamFile'\nimport 'cross-fetch/polyfill'\nimport Chunk from './chunk'\nimport { unzip } from '@gmod/bgzf-filehandle'\nimport { parseHeaderText } from './sam'\n\ninterface HeaderLine {\n  tag: string\n  value: string\n}\n\ninterface HtsgetChunk {\n  url: string\n  headers?: Record<string, string>\n}\nasync function concat(arr: { url: string }[], opts: Record<string, any>) {\n  const res = await Promise.all(\n    arr.map(async (chunk: HtsgetChunk) => {\n      const { url, headers } = chunk\n      if (url.startsWith('data:')) {\n        return Buffer.from(url.split(',')[1], 'base64')\n      } else {\n        //remove referer header, it is not even allowed to be specified\n        //@ts-ignore\n        //eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { referer, ...rest } = headers\n        const res = await fetch(url, { ...opts, headers: { ...opts.headers, ...rest } })\n        if (!res.ok) {\n          throw new Error(`Failed to fetch ${res.statusText}`)\n        }\n        return Buffer.from(await res.arrayBuffer())\n      }\n    }),\n  )\n\n  return Buffer.concat(await Promise.all(res.map(elt => unzip(elt))))\n}\n\nexport default class HtsgetFile extends BamFile {\n  private baseUrl: string\n\n  private trackId: string\n\n  constructor(args: { trackId: string; baseUrl: string }) {\n    // @ts-ignore override bam defaults\n    super({ bamFilehandle: '?', baiFilehandle: '?' })\n    this.baseUrl = args.baseUrl\n    this.trackId = args.trackId\n  }\n\n  async *streamRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts: BamOpts = { viewAsPairs: false, pairAcrossChr: false, maxInsertSize: 200000 },\n  ) {\n    const base = `${this.baseUrl}/${this.trackId}`\n    const url = `${base}?referenceName=${chr}&start=${min}&end=${max}&format=BAM`\n    const chrId = this.chrToIndex && this.chrToIndex[chr]\n    const result = await fetch(url, { ...opts })\n    if (!result.ok) {\n      throw new Error(result.statusText)\n    }\n    const data = await result.json()\n    const uncba = await concat(data.htsget.urls.slice(1), opts)\n    const chunk = {\n      buffer: uncba,\n      chunk: { minv: { dataPosition: 0 } },\n      toString() {\n        return `${chr}_${min}_${max}`\n      },\n    }\n\n    yield* this._fetchChunkFeatures(\n      // @ts-ignore\n      [chunk],\n      chrId,\n      min,\n      max,\n      opts,\n    )\n  }\n\n  //@ts-ignore\n  async _readChunk(params: { chunk: { buffer: Buffer; chunk: Chunk }; opts: BaseOpts }) {\n    const { chunk } = params\n    const { buffer, chunk: c2 } = chunk\n    return { data: buffer, cpositions: null, dpositions: null, chunk: c2 }\n  }\n\n  async getHeader(opts: BaseOpts = {}) {\n    const url = `${this.baseUrl}/${this.trackId}?referenceName=na&class=header`\n    const result = await fetch(url, opts)\n    if (!result.ok) {\n      throw new Error(`Failed to fetch ${result.statusText}`)\n    }\n    const data = await result.json()\n    const uncba = await concat(data.htsget.urls, opts)\n\n    if (uncba.readInt32LE(0) !== BAM_MAGIC) {\n      throw new Error('Not a BAM file')\n    }\n    const headLen = uncba.readInt32LE(4)\n\n    const headerText = uncba.toString('utf8', 8, 8 + headLen)\n    const samHeader = parseHeaderText(headerText)\n\n    // use the @SQ lines in the header to figure out the\n    // mapping between ref ref ID numbers and names\n    const idToName: string[] = []\n    const nameToId: Record<string, number> = {}\n    const sqLines = samHeader.filter((l: { tag: string }) => l.tag === 'SQ')\n    sqLines.forEach((sqLine: { data: HeaderLine[] }, refId: number) => {\n      sqLine.data.forEach((item: HeaderLine) => {\n        if (item.tag === 'SN') {\n          // this is the ref name\n          const refName = item.value\n          nameToId[refName] = refId\n          idToName[refId] = refName\n        }\n      })\n    })\n    this.chrToIndex = nameToId\n    this.indexToChr = idToName\n    return samHeader\n  }\n}\n","var _indexOfInstanceProperty = require(\"../core-js/instance/index-of\");\n\nvar _Object$getOwnPropertySymbols = require(\"../core-js/object/get-own-property-symbols\");\n\nvar objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (_Object$getOwnPropertySymbols) {\n    var sourceSymbolKeys = _Object$getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (_indexOfInstanceProperty(excluded).call(excluded, key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;","module.exports = require(\"core-js-pure/features/object/get-own-property-symbols\");","var parent = require('../../es/object/get-own-property-symbols');\n\nmodule.exports = parent;\n","var _indexOfInstanceProperty = require(\"../core-js/instance/index-of\");\n\nvar _Object$keys = require(\"../core-js/object/keys\");\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n\n  var sourceKeys = _Object$keys(source);\n\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (_indexOfInstanceProperty(excluded).call(excluded, key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;","module.exports = require(\"core-js-pure/features/object/keys\");","var parent = require('../../es/object/keys');\n\nmodule.exports = parent;\n","module.exports = require(\"core-js-pure/stable/instance/starts-with\");","var parent = require('../../es/instance/starts-with');\n\nmodule.exports = parent;\n","var startsWith = require('../string/virtual/starts-with');\n\nvar StringPrototype = String.prototype;\n\nmodule.exports = function (it) {\n  var own = it.startsWith;\n  return typeof it === 'string' || it === StringPrototype\n    || (it instanceof String && own === StringPrototype.startsWith) ? startsWith : own;\n};\n","require('../../../modules/es.string.starts-with');\nvar entryVirtual = require('../../../internals/entry-virtual');\n\nmodule.exports = entryVirtual('String').startsWith;\n","'use strict';\nvar $ = require('../internals/export');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar toLength = require('../internals/to-length');\nvar notARegExp = require('../internals/not-a-regexp');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\nvar correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');\nvar IS_PURE = require('../internals/is-pure');\n\n// eslint-disable-next-line es/no-string-prototype-startswith -- safe\nvar $startsWith = ''.startsWith;\nvar min = Math.min;\n\nvar CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith');\n// https://github.com/zloirock/core-js/pull/702\nvar MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {\n  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');\n  return descriptor && !descriptor.writable;\n}();\n\n// `String.prototype.startsWith` method\n// https://tc39.es/ecma262/#sec-string.prototype.startswith\n$({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {\n  startsWith: function startsWith(searchString /* , position = 0 */) {\n    var that = String(requireObjectCoercible(this));\n    notARegExp(searchString);\n    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));\n    var search = String(searchString);\n    return $startsWith\n      ? $startsWith.call(that, search, index)\n      : that.slice(index, index + search.length) === search;\n  }\n});\n","(function(self) {\n\nvar irrelevant = (function (exports) {\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  return exports;\n\n}({}));\n})(typeof self !== 'undefined' ? self : this);\n","var _Object$defineProperty = require(\"../core-js/object/define-property\");\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    _Object$defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","import BAI from './bai'\nimport CSI from './csi'\nimport BamFile from './bamFile'\nimport HtsgetFile from './htsget'\nimport BamRecord from './record'\n\nexport { BAI, CSI, BamFile, BamRecord, HtsgetFile }\n","module.exports = require(\"core-js-pure/features/get-iterator-method\");","module.exports = require(\"core-js-pure/stable/object/define-properties\");","module.exports = require(\"core-js-pure/stable/object/get-own-property-descriptors\");","module.exports = require(\"core-js-pure/stable/object/get-own-property-descriptor\");","module.exports = require(\"core-js-pure/stable/object/get-own-property-symbols\");","module.exports = require(\"core-js-pure/stable/reflect/construct\");","import Chunk from './chunk'\nimport VirtualOffset from './virtualOffset'\n\nexport function timeout(ms: number) {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n\nexport function longToNumber(long: Long) {\n  if (long.greaterThan(Number.MAX_SAFE_INTEGER) || long.lessThan(Number.MIN_SAFE_INTEGER)) {\n    throw new Error('integer overflow')\n  }\n  return long.toNumber()\n}\n\n/**\n * Properly check if the given AbortSignal is aborted.\n * Per the standard, if the signal reads as aborted,\n * this function throws either a DOMException AbortError, or a regular error\n * with a `code` attribute set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute\n * @returns nothing\n */\nexport function checkAbortSignal(signal?: AbortSignal) {\n  if (!signal) {\n    return\n  }\n\n  if (signal.aborted) {\n    // console.log('bam aborted!')\n    if (typeof DOMException !== 'undefined') {\n      throw new DOMException('aborted', 'AbortError')\n    } else {\n      const e = new Error('aborted')\n      //@ts-ignore\n      e.code = 'ERR_ABORTED'\n      throw e\n    }\n  }\n}\n\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nexport async function abortBreakPoint(signal?: AbortSignal) {\n  await Promise.resolve()\n  checkAbortSignal(signal)\n}\n\nexport function canMergeBlocks(chunk1: Chunk, chunk2: Chunk) {\n  return (\n    chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&\n    chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000\n  )\n}\n\nexport interface BamOpts {\n  viewAsPairs?: boolean\n  pairAcrossChr?: boolean\n  maxInsertSize?: number\n  signal?: AbortSignal\n}\n\nexport interface BaseOpts {\n  signal?: AbortSignal\n}\n\nexport function makeOpts(obj: AbortSignal | BaseOpts = {}): BaseOpts {\n  return 'aborted' in obj ? ({ signal: obj } as BaseOpts) : (obj as BaseOpts)\n}\n\nexport function optimizeChunks(chunks: Chunk[], lowest: VirtualOffset) {\n  const mergedChunks: Chunk[] = []\n  let lastChunk: Chunk | null = null\n\n  if (chunks.length === 0) {\n    return chunks\n  }\n\n  chunks.sort(function(c0, c1) {\n    const dif = c0.minv.blockPosition - c1.minv.blockPosition\n    if (dif !== 0) {\n      return dif\n    } else {\n      return c0.minv.dataPosition - c1.minv.dataPosition\n    }\n  })\n\n  chunks.forEach(chunk => {\n    if (!lowest || chunk.maxv.compareTo(lowest) > 0) {\n      if (lastChunk === null) {\n        mergedChunks.push(chunk)\n        lastChunk = chunk\n      } else {\n        if (canMergeBlocks(lastChunk, chunk)) {\n          if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {\n            lastChunk.maxv = chunk.maxv\n          }\n        } else {\n          mergedChunks.push(chunk)\n          lastChunk = chunk\n        }\n      }\n    }\n  })\n\n  return mergedChunks\n}\n"],"sourceRoot":""}